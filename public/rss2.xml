<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Shawn&#39;s Pitstop</title>
    <link>http://xcorpion.tech/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 12 Sep 2016 06:16:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>It&#39;s all about buffers: zero-copy, mmap and Java NIO</title>
      <link>http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/</link>
      <guid>http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/</guid>
      <pubDate>Sat, 10 Sep 2016 08:00:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;There are use cases where data need to be read from source to a sink without modification. In code this might look quite simple: for example in Java, you may read data from one &lt;code&gt;InputStream&lt;/code&gt; chunk by chunk into a small buffer (typically 8KB), and feed them into the &lt;code&gt;OutputStream&lt;/code&gt;, or even better, you could create a &lt;code&gt;PipedInputStream&lt;/code&gt;, which is basically just a util that maintains that buffer for you. However, if low latency is crucial to your software, this might be quite expensive from the OS perspective and I shall explain.&lt;/p&gt;
&lt;h2 id=&quot;What-happens-under-the-hood&quot;&gt;&lt;a href=&quot;#What-happens-under-the-hood&quot; class=&quot;headerlink&quot; title=&quot;What happens under the hood&quot;&gt;&lt;/a&gt;What happens under the hood&lt;/h2&gt;&lt;p&gt;Well, here’s what happens when the above code is used:&lt;/p&gt;
&lt;img src=&quot;/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/non_zero_copy.png&quot; alt=&quot;non_zero_copy.png&quot; title=&quot;&quot;&gt;
&lt;ol&gt;
&lt;li&gt;JVM sends read() syscall. &lt;/li&gt;
&lt;li&gt;OS context switches to kernel mode and reads data into the input socket buffer.&lt;/li&gt;
&lt;li&gt;OS kernel then copies data into user buffer, and context switches back to user mode. read() returns.&lt;/li&gt;
&lt;li&gt;JVM processes code logic and sends write() syscall.&lt;/li&gt;
&lt;li&gt;OS context switches to kernel mode and copies data from user buffer to output socket buffer.&lt;/li&gt;
&lt;li&gt;OS returns to user mode and logic in JVM continues.&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>There are use cases where data need to be read from source to a sink without modification. In code this might look quite simple: for example in Java, you may read data from one <code>InputStream</code> chunk by chunk into a small buffer (typically 8KB), and feed them into the <code>OutputStream</code>, or even better, you could create a <code>PipedInputStream</code>, which is basically just a util that maintains that buffer for you. However, if low latency is crucial to your software, this might be quite expensive from the OS perspective and I shall explain.</p>
<h2 id="What-happens-under-the-hood"><a href="#What-happens-under-the-hood" class="headerlink" title="What happens under the hood"></a>What happens under the hood</h2><p>Well, here’s what happens when the above code is used:</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/non_zero_copy.png" alt="non_zero_copy.png" title="">
<ol>
<li>JVM sends read() syscall. </li>
<li>OS context switches to kernel mode and reads data into the input socket buffer.</li>
<li>OS kernel then copies data into user buffer, and context switches back to user mode. read() returns.</li>
<li>JVM processes code logic and sends write() syscall.</li>
<li>OS context switches to kernel mode and copies data from user buffer to output socket buffer.</li>
<li>OS returns to user mode and logic in JVM continues.</li>
</ol>
<a id="more"></a>
<p>This would be fine if latency and throughput aren’t your service’s concern or bottleneck, but it would be annoying if you do care, say for a static asset server. There are 4 context switches and 2 unnecessary copies for the above example.</p>
<h2 id="OS-level-zero-copy-for-the-rescue"><a href="#OS-level-zero-copy-for-the-rescue" class="headerlink" title="OS-level zero copy for the rescue"></a>OS-level zero copy for the rescue</h2><p>Clearly in this use case, the copy from/to user space memory is totally unnecessary because we didn’t do anything other than dumping data to a different socket. Zero copy can thus be used here to save the 2 extra copies. The actual implementation doesn’t really have a standard and is up to the OS how to achieve that. Typically *nix systems will offer <code>sendfile()</code>. Its man page can be found <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">here</a>. Some say some operating systems have broken versions of that with one of them being OSX <a href="https://blog.phusion.nl/2015/06/04/the-brokenness-of-the-sendfile-system-call/" target="_blank" rel="external">link</a>. Honestly with such low-level feature, I wouldn’t trust Apple’s BSD-like system so never tested there.</p>
<p>With that, the diagram would be like this:</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/zero_copy.png" alt="zero_copy.png" title="">
<p>You may say OS still has to make a copy of the data in kernel memory space. Yes but from OS’s perspective this is already zero-copy because there’s no data copied from kernel space to user space. The reason why kernel needs to make a copy is because general hardware DMA access expects consecutive memory space (and hence the buffer). However this is avoidable if the hardware supports scatter-n-gather:</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/scattergather.png" alt="scattergather.png" title="">
<p>A lot of web servers do support zero-copy such as Tomcat and Apache. For example apache’s related doc can be found <a href="https://httpd.apache.org/docs/2.4/mod/core.html#enablesendfile" target="_blank" rel="external">here</a> but by default it’s off.</p>
<p>Note: Java’s NIO offers this through <code>transferTo</code> (<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-" target="_blank" rel="external">doc</a>).</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>The problem with the above zero-copy approach is that because there’s no user mode actually involved, code cannot do anything other than piping the stream. However, there’s a more expensive yet more useful approach - mmap, short for memory-map.</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/mmap.png" alt="mmap.png" title="">
<p>Mmap allows code to map file to kernel memory and access that directly as if it were in the application user space, thus avoiding the unnecessary copy. As a tradeoff, that will still involve 4 context switches. But since OS maps certain chunk of file into memory, you get all benefits from OS virtual memory management - hot content can be intelligently cached efficiently, and all data are page-aligned thus no buffer copying is needed to write stuff back.</p>
<p>However, nothing comes for free - while mmap does avoid that extra copy, it doesn’t guarantee the code will always be faster - depending on the OS implementation, there may be quite a bit of setup and teardown overhead (since it needs to find the space and maintain it in the TLB and make sure to flush it after unmapping) and page fault gets much more expensive since kernel now needs to read from hardware (like disk) to update the memory space and TLB. Hence, if performance is this critical, benchmark is always needed as abusing mmap() may yield worse performance than simply doing the copy.</p>
<p>The corresponding class in Java is <code>MappedByteBuffer</code> from NIO package. It’s actually a variation of <code>DirectByteBuffer</code> though there’s no direct relationship between classes. The actual usage is out of scope of this post.</p>
<h2 id="NIO-DirectByteBuffer"><a href="#NIO-DirectByteBuffer" class="headerlink" title="NIO DirectByteBuffer"></a>NIO DirectByteBuffer</h2><p>Java NIO introduces <code>ByteBuffer</code> which represents the buffer area used for channels. There are 3 main implementations of <code>ByteBuffer</code>:</p>
<ol>
<li><p><code>HeapByteBuffer</code></p>
<p> This is used when <code>ByteBuffer.allocate()</code> is called. It’s called heap because it’s maintained in JVM’s heap space and hence you get all benefits like GC support and caching optimization. However, it’s not page aligned, which means if you need to talk to native code through JNI, JVM would have to make a copy to the aligned buffer space.</p>
</li>
<li><p><code>DirectByteBuffer</code></p>
<p> Used when <code>ByteBuffer.allocateDirect()</code> is called. JVM will allocate memory space outside the heap space using <code>malloc()</code>. Because it’s not managed by JVM, your memory space is page-aligned and not subject to GC, which makes it perfect candidate for working with native code (e.g. when writing OpenGL stuff). However, you are then “deteriorated” to C programmer as you’ll have to allocate and deallocate memory yourself to prevent memory leak.</p>
</li>
<li><p><code>MappedByteBuffer</code></p>
<p> Used when <code>FileChannel.map()</code> is called. Similar to <code>DirectByteBuffer</code> this is also outside of JVM heap. It essentially functions as a wrapper around OS mmap() system call in order for code to directly manipulate mapped physical memory data.</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><code>sendfile()</code> and <code>mmap()</code> offer efficient, low-latency low-level solutions to data manipulation across sockets. Again, no code should assume these are silver bullets as real world scenarios may be complex and it might not be worth the effort to switch code to them if this is not the true bottleneck. For software engineering to get the most ROI, in most cases, it’s better to “make it right” and then “make it fast”. Without the guardrails offered by JVM, it’s easy to make software much more vulnerable to crashing (I literally mean crashing, not exceptions) when it comes to complicated logic.</p>
<h2 id="Quick-Reference"><a href="#Quick-Reference" class="headerlink" title="Quick Reference"></a>Quick Reference</h2><p><a href="https://www.ibm.com/developerworks/library/j-zerocopy/" target="_blank" rel="external">Efficient data transfer through zero copy</a> - It also covers sendfile() performance comparison.</p>
<p><a href="http://www.ibm.com/developerworks/java/tutorials/j-nio/j-nio.html" target="_blank" rel="external">Getting started with new I/O (NIO)</a></p>
]]></content:encoded>
      
      <comments>http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Get Started with Hexo Blogging System</title>
      <link>http://xcorpion.tech/2016/08/14/get-started-with-hexo-blogging-system/</link>
      <guid>http://xcorpion.tech/2016/08/14/get-started-with-hexo-blogging-system/</guid>
      <pubDate>Sun, 14 Aug 2016 21:32:53 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;You-should-read-this-if&quot;&gt;&lt;a href=&quot;#You-should-read-this-if&quot; class=&quot;headerlink&quot; title=&quot;You should read this if&quot;&gt;&lt;/a&gt;You should read this if&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;You want to set up a personal blog&lt;/li&gt;
&lt;li&gt;You know what &lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&quot;&gt;Markdown&lt;/a&gt; is&lt;/li&gt;
&lt;li&gt;You don’t want to set up a heavy Wordpress environment&lt;/li&gt;
&lt;li&gt;You don’t want to set up any database just for the blog&lt;/li&gt;
&lt;li&gt;You either don’t have a VPS or want to host blog content in some easy-to-reach place.&lt;/li&gt;
&lt;li&gt;You still want a template/theme system.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;Github Pages + Hexo (what this site uses)&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="You-should-read-this-if"><a href="#You-should-read-this-if" class="headerlink" title="You should read this if"></a>You should read this if</h1><ul>
<li>You want to set up a personal blog</li>
<li>You know what <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="external">Markdown</a> is</li>
<li>You don’t want to set up a heavy Wordpress environment</li>
<li>You don’t want to set up any database just for the blog</li>
<li>You either don’t have a VPS or want to host blog content in some easy-to-reach place.</li>
<li>You still want a template/theme system.</li>
</ul>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Github Pages + Hexo (what this site uses)</p>
<a id="more"></a>
<h1 id="What-is-Hexo"><a href="#What-is-Hexo" class="headerlink" title="What is Hexo"></a>What is Hexo</h1><p>“<a href="https://hexo.io/docs/index.html" target="_blank" rel="external">Hexo</a> is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.”</p>
<p>In other words, Hexo is a <strong>static</strong> blogging system. This means there is no need for database, node/php code to maintain like Wordpress or other dynamic blogging systems require. Awesome.</p>
<h1 id="How-on-earth-do-things-work"><a href="#How-on-earth-do-things-work" class="headerlink" title="How on earth do things work"></a>How on earth do things work</h1><ul>
<li>You write posts using Markdown language and preview them locally</li>
<li>Hexo generates the static htmls locally</li>
<li>You commit all static assets to Github</li>
<li>All content will be public via Github IO<ul>
<li>When you hit path that ends with /, Github will attempt to read index.html under that directory, i.e. for /foo/, the corresponding file is /foo/index.html</li>
<li>For URLs don’t end with / (except root), Github will try to read the corresponding file, i.e. for /foo, if file foo doesn’t exist, 404 will be returned.</li>
<li>Generally, Hexo’s path layout should be fine but if you use certain themes (like the default landscape), you might need to fix the URLs manually if they don’t end with / while they should.</li>
</ul>
</li>
</ul>
<h1 id="What-this-solution-cannot-do"><a href="#What-this-solution-cannot-do" class="headerlink" title="What this solution cannot do"></a>What this solution cannot do</h1><p>You can think of Hexo as a lightweight templating system so most dynamic features that Wordpress offer don’t exist, including searching (provided by simple google search instead), comment system (you can use Disqus instead), dynamic widgets like top posts, permalink backend forwarding and so on.</p>
<p>However, do you really need these?</p>
<h1 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h1><p>If you’ve read this far, chances are you want to give it a try. Here are the steps:</p>
<ol>
<li><p>Install node (required by Hexo): <a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a></p>
</li>
<li><p>Install Hexo</p>
<pre><code>npm install -g hexo-cli

// this downloads the starter pack and sets up node modules under the directory &lt;name&gt; for you so it may take a while
hexo init &lt;name&gt;
</code></pre></li>
<li><p>Open <code>&lt;name&gt;/_config.yml</code> and there may be a few things you want to set such as the name and author. The most important things are the <code>url</code> and <code>root</code>. The details can be found <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">here</a></p>
</li>
<li><p>By default Hexo will generate the Hello world post for you. You can preview it by starting the local server:</p>
<pre><code>hexo server
</code></pre></li>
<li><p>Generate actual assets:</p>
<pre><code>hexo generate
</code></pre></li>
<li><p>Set up Github page repo: <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
</li>
</ol>
<p>Depending on if you have a VPS, things maybe a bit different. Follow 7a if you do and 7b if not. The major difference is the directory structure in the repo.</p>
<p>7a-1. Hexo by default publishes all static assets to <code>public</code>. However, Github by default expects stuff to be under root. That means, with this setup, the repo needs to be rooted at <code>public</code>:</p>
<pre><code>cd public
git init
git remote add origin &lt;repo url&gt;
git pull
</code></pre><p>7a-2. Commit all assets:</p>
<pre><code>git add --all
git commit -m &quot;...&quot;
git push
</code></pre><p>7a-3. If you have a custom domain, set CNAME pointed to your.github.io and remember to disable https enforcement in Github (since SSL will verify host name). Also don’t forget to set the custom url in Github.</p>
<hr>
<p>7b-1. If you have a VPS then you can commit all the files and just use github as the storage area since you can do backend url forwarding.</p>
<figure class="highlight nginx"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span>  xcorpion.tech;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_set_header</span> Host xcorpion.tech;</div><div class="line">        <span class="attribute">proxy_pass</span> http://your.github.io/public/;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7b-2. If you have a custom domain, set A record pointed to your server IP and similarily, remember to turn off https enforcement. Also don’t forget to set the custom url in Github.</p>
<h1 id="And-that’s-it-Let’s-start-writing"><a href="#And-that’s-it-Let’s-start-writing" class="headerlink" title="And that’s it! Let’s start writing!"></a>And that’s it! Let’s start writing!</h1><ul>
<li><p>In your hexo root directory, start a new post:</p>
<pre><code>hexo new post
</code></pre></li>
<li><p>Preview your post with</p>
<pre><code>hexo server
</code></pre></li>
<li><p>In preview mode, Hexo will watch your files and automatically update the html. However, it <strong>will not</strong> publish any static assets (those eventually shown in your site). So run this to let hexo do it:</p>
<pre><code>hexo generate
</code></pre></li>
<li><p>Then commit the changes to your repo (You can automate this with a shell script.)</p>
</li>
</ul>
]]></content:encoded>
      
      <comments>http://xcorpion.tech/2016/08/14/get-started-with-hexo-blogging-system/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
