<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Shawn&#39;s Pitstop</title>
    <link>http://xcorpion.tech/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 18 Sep 2016 19:42:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Why you should ditch Browserify and CommonJS in the http/2 world</title>
      <link>http://xcorpion.tech/2016/09/18/Why-you-should-ditch-browserify-and-commonjs-in-the-http-2-world/</link>
      <guid>http://xcorpion.tech/2016/09/18/Why-you-should-ditch-browserify-and-commonjs-in-the-http-2-world/</guid>
      <pubDate>Sun, 18 Sep 2016 17:15:36 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;alert info no-icon&quot;&gt;&lt;p&gt;Stop bundling in the http/2 world since it does it for you.&lt;/p&gt;
&lt;/div&gt;
&lt;!-- toc --&gt;
&lt;h1 id=&quot;Modularization-is-a-great-idea&quot;&gt;&lt;a href=&quot;#Modularization-is-a-great-idea&quot; class=&quot;headerlink&quot; title=&quot;Modularization is a great idea&quot;&gt;&lt;/a&gt;Modularization is a great idea&lt;/h1&gt;&lt;p&gt;Back in the old days where there were no concept regarding frontend package management, we would lay out all the scripts in order in the html file, and hope for the best that they would somehow work together if order were right. This surely doesn’t work well with huge projects, but luckily back then JavaScripts weren’t so shiny anyways - UIs weren’t so cool and logic was much simpler. However, things do evolve. People soon noticed that this approach wouldn’t scale - cooperation across multiple teams becomes super tricky, if not impossible, and it doesn’t play well with DRY either.&lt;/p&gt;
&lt;p&gt;Then people came up with a great idea of modularizing JS code (probably back in 2003?) the same way you would do for your beloved Java/C++ code libraries. And then there came the CommonJS definition concept by Kevin Dangoor back in 2009. Many people got to know this idea thanks to Node.js, and it works quite well, especially for server side code. Now you can easily use npm and build both the frontend and backend using the same tool very quickly, thanks to the JS community. Since people have the same interface for code modularization, team cooperation becomes much easier and projects gain benefit from much better encapsulation.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<div class="alert info no-icon"><p>Stop bundling in the http/2 world since it does it for you.</p>
</div>
<!-- toc -->
<h1 id="Modularization-is-a-great-idea"><a href="#Modularization-is-a-great-idea" class="headerlink" title="Modularization is a great idea"></a>Modularization is a great idea</h1><p>Back in the old days where there were no concept regarding frontend package management, we would lay out all the scripts in order in the html file, and hope for the best that they would somehow work together if order were right. This surely doesn’t work well with huge projects, but luckily back then JavaScripts weren’t so shiny anyways - UIs weren’t so cool and logic was much simpler. However, things do evolve. People soon noticed that this approach wouldn’t scale - cooperation across multiple teams becomes super tricky, if not impossible, and it doesn’t play well with DRY either.</p>
<p>Then people came up with a great idea of modularizing JS code (probably back in 2003?) the same way you would do for your beloved Java/C++ code libraries. And then there came the CommonJS definition concept by Kevin Dangoor back in 2009. Many people got to know this idea thanks to Node.js, and it works quite well, especially for server side code. Now you can easily use npm and build both the frontend and backend using the same tool very quickly, thanks to the JS community. Since people have the same interface for code modularization, team cooperation becomes much easier and projects gain benefit from much better encapsulation.</p>
<a id="more"></a>
<h1 id="And-browserify-was-a-great-tool"><a href="#And-browserify-was-a-great-tool" class="headerlink" title="And browserify was a great tool"></a>And browserify was a great tool</h1><p>Browerify is a bundling tool based on CommonJS definition by providing polyfill for <code>require</code> and <code>define</code> calls in browser. Back in the days when AMD wasn’t ready, it gave people an easy way of defining your modules the same way as for other node modules and serving everything together as one giant bundle. The idea is based on the fact that browsers have concurrent http request limit, let alone now full-site https becomes popular and SSL handshaking is quite expensive. So by bundling, you cut the number of required requests and hence you get faster page loading.</p>
<h1 id="However-there-are-a-few-small-problems…"><a href="#However-there-are-a-few-small-problems…" class="headerlink" title="However, there are a few small problems…"></a>However, there are a few small problems…</h1><p>Unlike AMD, CommonJS is synchronous and you can tell from their API design:</p>
<figure class="highlight js"><figcaption><span>AMD</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">foo, bar</span>) </span>&#123;</div><div class="line">    <span class="comment">// code begins</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>CommonJS</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">require</span>(<span class="string">'bar'</span>);</div><div class="line"></div><div class="line"><span class="comment">// code begins</span></div></pre></td></tr></table></figure>
<p>It’s easy to load AMD modules asynchronously because the actual code lives in a callback so your loader can play scatter-n-gather. For CommonJS, however, each require call would have to wait until the previous one comes back, which means the loader cannot utilize Ajax and spread the load to multiple http requests in order to speed up the loading process. The solution for browserify is to bundle everything together and hence it can just grab that reference for you in a map. However, if your code library is huge, then it means your initial page load time and above-the-fold time (time between user hits enter and the content in the current browser window stops changing) will be negatively impacted. Moreover, on demand module loading becomes impossible here while in AMD, it’s pretty simple.</p>
<p>Another problem with browserify, which is the main reason why I don’t like it, is that bundling becomes mandatory. This makes local dev environment setup and testing tricky and surprise-prone. Using browserify means if my app requires ABC in general, I still need to bundle everything together while I just want to test C. To me that’s just ridiculous.</p>
<h1 id="And-http-2-increases-the-gap"><a href="#And-http-2-increases-the-gap" class="headerlink" title="And http/2 increases the gap"></a>And http/2 increases the gap</h1><p>Http/2 introduces multiplexing which makes CommonJS approach even more crippled. Multiplexing means now you can use one TCP connection to transfer different content from different sources, which makes asynchronous module loading greater. But if you bundle everything together, sorry you are just ignoring all those benefits.</p>
<p>A lot of CDNs support http/2 now, including Akamai, Cloudflare and Cloudfront, you name it. Here’s a demo from cloudflare:</p>
<img src="/2016/09/18/Why-you-should-ditch-browserify-and-commonjs-in-the-http-2-world/comparison.gif" alt="comparison.gif" title="">
<p>(Tested in Chrome 53.0)</p>
<h1 id="So-what-to-use-instead"><a href="#So-what-to-use-instead" class="headerlink" title="So what to use instead?"></a>So what to use instead?</h1><p>ECMA 6 is really the way to go. It consolidates the nice API design from CommonJS and the asynchronous and on-demand module loading feature from AMD. Currently, most browsers don’t support it yet (as of Sep 2016). Surprisingly Microsoft leads the way this time by <a href="https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond" target="_blank" rel="external">allowing you to turn on this experimental feature</a>. Regardless of that, Babel can help you turn es6 code to es5, and System.js can fill the gap as the module loader.</p>
<p>JSPM, Babel and System.js is a good combination for the time being. Everything just works seamlessly across different scenarios - you don’t need to bundle anything in dev environment while getting all the benefits in production with the same set of configuration. You have the freedom - choose to bundle your scripts for best performance for legacy browser support, or on demand, no bundling for best performance under http/2. The actual workflow configuration is out of the scope of this post. I’ll write a post later to discuss this in details, including comparison with the popular bundler - webpack.</p>
<p>However, if you can’t switch to that for some reason, you can still keep using AMD. The major problems with AMD are:</p>
<ol>
<li>tedious API design (I don’t see how this can be changed without a transpiler due to native JS limit)</li>
<li>not friendly to IDE due to separation of module naming and configuration (and webpack suffers from similar issues)</li>
</ol>
<p>Http/2 makes a lot of old “golden rules” no longer correct. Spriting for images and bundling for scripts used to be so true that some people just blindly follow them. However, the world keeps involving so time to keep our eyes open.</p>
]]></content:encoded>
      
      <comments>http://xcorpion.tech/2016/09/18/Why-you-should-ditch-browserify-and-commonjs-in-the-http-2-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>It&#39;s all about buffers: zero-copy, mmap and Java NIO</title>
      <link>http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/</link>
      <guid>http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/</guid>
      <pubDate>Sat, 10 Sep 2016 08:00:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;There are use cases where data need to be read from source to a sink without modification. In code this might look quite simple: for example in Java, you may read data from one &lt;code&gt;InputStream&lt;/code&gt; chunk by chunk into a small buffer (typically 8KB), and feed them into the &lt;code&gt;OutputStream&lt;/code&gt;, or even better, you could create a &lt;code&gt;PipedInputStream&lt;/code&gt;, which is basically just a util that maintains that buffer for you. However, if low latency is crucial to your software, this might be quite expensive from the OS perspective and I shall explain.&lt;/p&gt;
&lt;h2 id=&quot;What-happens-under-the-hood&quot;&gt;&lt;a href=&quot;#What-happens-under-the-hood&quot; class=&quot;headerlink&quot; title=&quot;What happens under the hood&quot;&gt;&lt;/a&gt;What happens under the hood&lt;/h2&gt;&lt;p&gt;Well, here’s what happens when the above code is used:&lt;/p&gt;
&lt;img src=&quot;/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/non_zero_copy.png&quot; alt=&quot;non_zero_copy.png&quot; title=&quot;&quot;&gt;
&lt;ol&gt;
&lt;li&gt;JVM sends read() syscall. &lt;/li&gt;
&lt;li&gt;OS context switches to kernel mode and reads data into the input socket buffer.&lt;/li&gt;
&lt;li&gt;OS kernel then copies data into user buffer, and context switches back to user mode. read() returns.&lt;/li&gt;
&lt;li&gt;JVM processes code logic and sends write() syscall.&lt;/li&gt;
&lt;li&gt;OS context switches to kernel mode and copies data from user buffer to output socket buffer.&lt;/li&gt;
&lt;li&gt;OS returns to user mode and logic in JVM continues.&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>There are use cases where data need to be read from source to a sink without modification. In code this might look quite simple: for example in Java, you may read data from one <code>InputStream</code> chunk by chunk into a small buffer (typically 8KB), and feed them into the <code>OutputStream</code>, or even better, you could create a <code>PipedInputStream</code>, which is basically just a util that maintains that buffer for you. However, if low latency is crucial to your software, this might be quite expensive from the OS perspective and I shall explain.</p>
<h2 id="What-happens-under-the-hood"><a href="#What-happens-under-the-hood" class="headerlink" title="What happens under the hood"></a>What happens under the hood</h2><p>Well, here’s what happens when the above code is used:</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/non_zero_copy.png" alt="non_zero_copy.png" title="">
<ol>
<li>JVM sends read() syscall. </li>
<li>OS context switches to kernel mode and reads data into the input socket buffer.</li>
<li>OS kernel then copies data into user buffer, and context switches back to user mode. read() returns.</li>
<li>JVM processes code logic and sends write() syscall.</li>
<li>OS context switches to kernel mode and copies data from user buffer to output socket buffer.</li>
<li>OS returns to user mode and logic in JVM continues.</li>
</ol>
<a id="more"></a>
<p>This would be fine if latency and throughput aren’t your service’s concern or bottleneck, but it would be annoying if you do care, say for a static asset server. There are 4 context switches and 2 unnecessary copies for the above example.</p>
<h2 id="OS-level-zero-copy-for-the-rescue"><a href="#OS-level-zero-copy-for-the-rescue" class="headerlink" title="OS-level zero copy for the rescue"></a>OS-level zero copy for the rescue</h2><p>Clearly in this use case, the copy from/to user space memory is totally unnecessary because we didn’t do anything other than dumping data to a different socket. Zero copy can thus be used here to save the 2 extra copies. The actual implementation doesn’t really have a standard and is up to the OS how to achieve that. Typically *nix systems will offer <code>sendfile()</code>. Its man page can be found <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">here</a>. Some say some operating systems have broken versions of that with one of them being OSX <a href="https://blog.phusion.nl/2015/06/04/the-brokenness-of-the-sendfile-system-call/" target="_blank" rel="external">link</a>. Honestly with such low-level feature, I wouldn’t trust Apple’s BSD-like system so never tested there.</p>
<p>With that, the diagram would be like this:</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/zero_copy.png" alt="zero_copy.png" title="">
<p>You may say OS still has to make a copy of the data in kernel memory space. Yes but from OS’s perspective this is already zero-copy because there’s no data copied from kernel space to user space. The reason why kernel needs to make a copy is because general hardware DMA access expects consecutive memory space (and hence the buffer). However this is avoidable if the hardware supports scatter-n-gather:</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/scattergather.png" alt="scattergather.png" title="">
<p>A lot of web servers do support zero-copy such as Tomcat and Apache. For example apache’s related doc can be found <a href="https://httpd.apache.org/docs/2.4/mod/core.html#enablesendfile" target="_blank" rel="external">here</a> but by default it’s off.</p>
<p>Note: Java’s NIO offers this through <code>transferTo</code> (<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-" target="_blank" rel="external">doc</a>).</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>The problem with the above zero-copy approach is that because there’s no user mode actually involved, code cannot do anything other than piping the stream. However, there’s a more expensive yet more useful approach - mmap, short for memory-map.</p>
<img src="/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/mmap.png" alt="mmap.png" title="">
<p>Mmap allows code to map file to kernel memory and access that directly as if it were in the application user space, thus avoiding the unnecessary copy. As a tradeoff, that will still involve 4 context switches. But since OS maps certain chunk of file into memory, you get all benefits from OS virtual memory management - hot content can be intelligently cached efficiently, and all data are page-aligned thus no buffer copying is needed to write stuff back.</p>
<p>However, nothing comes for free - while mmap does avoid that extra copy, it doesn’t guarantee the code will always be faster - depending on the OS implementation, there may be quite a bit of setup and teardown overhead (since it needs to find the space and maintain it in the TLB and make sure to flush it after unmapping) and page fault gets much more expensive since kernel now needs to read from hardware (like disk) to update the memory space and TLB. Hence, if performance is this critical, benchmark is always needed as abusing mmap() may yield worse performance than simply doing the copy.</p>
<p>The corresponding class in Java is <code>MappedByteBuffer</code> from NIO package. It’s actually a variation of <code>DirectByteBuffer</code> though there’s no direct relationship between classes. The actual usage is out of scope of this post.</p>
<h2 id="NIO-DirectByteBuffer"><a href="#NIO-DirectByteBuffer" class="headerlink" title="NIO DirectByteBuffer"></a>NIO DirectByteBuffer</h2><p>Java NIO introduces <code>ByteBuffer</code> which represents the buffer area used for channels. There are 3 main implementations of <code>ByteBuffer</code>:</p>
<ol>
<li><p><code>HeapByteBuffer</code></p>
<p> This is used when <code>ByteBuffer.allocate()</code> is called. It’s called heap because it’s maintained in JVM’s heap space and hence you get all benefits like GC support and caching optimization. However, it’s not page aligned, which means if you need to talk to native code through JNI, JVM would have to make a copy to the aligned buffer space.</p>
</li>
<li><p><code>DirectByteBuffer</code></p>
<p> Used when <code>ByteBuffer.allocateDirect()</code> is called. JVM will allocate memory space outside the heap space using <code>malloc()</code>. Because it’s not managed by JVM, your memory space is page-aligned and not subject to GC, which makes it perfect candidate for working with native code (e.g. when writing OpenGL stuff). However, you are then “deteriorated” to C programmer as you’ll have to allocate and deallocate memory yourself to prevent memory leak.</p>
</li>
<li><p><code>MappedByteBuffer</code></p>
<p> Used when <code>FileChannel.map()</code> is called. Similar to <code>DirectByteBuffer</code> this is also outside of JVM heap. It essentially functions as a wrapper around OS mmap() system call in order for code to directly manipulate mapped physical memory data.</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><code>sendfile()</code> and <code>mmap()</code> offer efficient, low-latency low-level solutions to data manipulation across sockets. Again, no code should assume these are silver bullets as real world scenarios may be complex and it might not be worth the effort to switch code to them if this is not the true bottleneck. For software engineering to get the most ROI, in most cases, it’s better to “make it right” and then “make it fast”. Without the guardrails offered by JVM, it’s easy to make software much more vulnerable to crashing (I literally mean crashing, not exceptions) when it comes to complicated logic.</p>
<h2 id="Quick-Reference"><a href="#Quick-Reference" class="headerlink" title="Quick Reference"></a>Quick Reference</h2><p><a href="https://www.ibm.com/developerworks/library/j-zerocopy/" target="_blank" rel="external">Efficient data transfer through zero copy</a> - It also covers sendfile() performance comparison.</p>
<p><a href="http://www.ibm.com/developerworks/java/tutorials/j-nio/j-nio.html" target="_blank" rel="external">Getting started with new I/O (NIO)</a></p>
]]></content:encoded>
      
      <comments>http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Get Started with Hexo Blogging System</title>
      <link>http://xcorpion.tech/2016/08/14/get-started-with-hexo-blogging-system/</link>
      <guid>http://xcorpion.tech/2016/08/14/get-started-with-hexo-blogging-system/</guid>
      <pubDate>Sun, 14 Aug 2016 21:32:53 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;You-should-read-this-if&quot;&gt;&lt;a href=&quot;#You-should-read-this-if&quot; class=&quot;headerlink&quot; title=&quot;You should read this if&quot;&gt;&lt;/a&gt;You should read this if&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;You want to set up a personal blog&lt;/li&gt;
&lt;li&gt;You know what &lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&quot;&gt;Markdown&lt;/a&gt; is&lt;/li&gt;
&lt;li&gt;You don’t want to set up a heavy Wordpress environment&lt;/li&gt;
&lt;li&gt;You don’t want to set up any database just for the blog&lt;/li&gt;
&lt;li&gt;You either don’t have a VPS or want to host blog content in some easy-to-reach place.&lt;/li&gt;
&lt;li&gt;You still want a template/theme system.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;Github Pages + Hexo (what this site uses)&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="You-should-read-this-if"><a href="#You-should-read-this-if" class="headerlink" title="You should read this if"></a>You should read this if</h1><ul>
<li>You want to set up a personal blog</li>
<li>You know what <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="external">Markdown</a> is</li>
<li>You don’t want to set up a heavy Wordpress environment</li>
<li>You don’t want to set up any database just for the blog</li>
<li>You either don’t have a VPS or want to host blog content in some easy-to-reach place.</li>
<li>You still want a template/theme system.</li>
</ul>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Github Pages + Hexo (what this site uses)</p>
<a id="more"></a>
<h1 id="What-is-Hexo"><a href="#What-is-Hexo" class="headerlink" title="What is Hexo"></a>What is Hexo</h1><p>“<a href="https://hexo.io/docs/index.html" target="_blank" rel="external">Hexo</a> is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.”</p>
<p>In other words, Hexo is a <strong>static</strong> blogging system. This means there is no need for database, node/php code to maintain like Wordpress or other dynamic blogging systems require. Awesome.</p>
<h1 id="How-on-earth-do-things-work"><a href="#How-on-earth-do-things-work" class="headerlink" title="How on earth do things work"></a>How on earth do things work</h1><ul>
<li>You write posts using Markdown language and preview them locally</li>
<li>Hexo generates the static htmls locally</li>
<li>You commit all static assets to Github</li>
<li>All content will be public via Github IO<ul>
<li>When you hit path that ends with /, Github will attempt to read index.html under that directory, i.e. for /foo/, the corresponding file is /foo/index.html</li>
<li>For URLs don’t end with / (except root), Github will try to read the corresponding file, i.e. for /foo, if file foo doesn’t exist, 404 will be returned.</li>
<li>Generally, Hexo’s path layout should be fine but if you use certain themes (like the default landscape), you might need to fix the URLs manually if they don’t end with / while they should.</li>
</ul>
</li>
</ul>
<h1 id="What-this-solution-cannot-do"><a href="#What-this-solution-cannot-do" class="headerlink" title="What this solution cannot do"></a>What this solution cannot do</h1><p>You can think of Hexo as a lightweight templating system so most dynamic features that Wordpress offer don’t exist, including searching (provided by simple google search instead), comment system (you can use Disqus instead), dynamic widgets like top posts, permalink backend forwarding and so on.</p>
<p>However, do you really need these?</p>
<h1 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h1><p>If you’ve read this far, chances are you want to give it a try. Here are the steps:</p>
<ol>
<li><p>Install node (required by Hexo): <a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a></p>
</li>
<li><p>Install Hexo</p>
<pre><code>npm install -g hexo-cli

// this downloads the starter pack and sets up node modules under the directory &lt;name&gt; for you so it may take a while
hexo init &lt;name&gt;
</code></pre></li>
<li><p>Open <code>&lt;name&gt;/_config.yml</code> and there may be a few things you want to set such as the name and author. The most important things are the <code>url</code> and <code>root</code>. The details can be found <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">here</a></p>
</li>
<li><p>By default Hexo will generate the Hello world post for you. You can preview it by starting the local server:</p>
<pre><code>hexo server
</code></pre></li>
<li><p>Generate actual assets:</p>
<pre><code>hexo generate
</code></pre></li>
<li><p>Set up Github page repo: <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
</li>
</ol>
<p>Depending on if you have a VPS, things maybe a bit different. Follow 7a if you do and 7b if not. The major difference is the directory structure in the repo.</p>
<p>7a-1. Hexo by default publishes all static assets to <code>public</code>. However, Github by default expects stuff to be under root. That means, with this setup, the repo needs to be rooted at <code>public</code>:</p>
<pre><code>cd public
git init
git remote add origin &lt;repo url&gt;
git pull
</code></pre><p>7a-2. Commit all assets:</p>
<pre><code>git add --all
git commit -m &quot;...&quot;
git push
</code></pre><p>7a-3. If you have a custom domain, set CNAME pointed to your.github.io and remember to disable https enforcement in Github (since SSL will verify host name). Also don’t forget to set the custom url in Github.</p>
<hr>
<p>7b-1. If you have a VPS then you can commit all the files and just use github as the storage area since you can do backend url forwarding.</p>
<figure class="highlight nginx"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span>  xcorpion.tech;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_set_header</span> Host xcorpion.tech;</div><div class="line">        <span class="attribute">proxy_pass</span> http://your.github.io/public/;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7b-2. If you have a custom domain, set A record pointed to your server IP and similarily, remember to turn off https enforcement. Also don’t forget to set the custom url in Github.</p>
<h1 id="And-that’s-it-Let’s-start-writing"><a href="#And-that’s-it-Let’s-start-writing" class="headerlink" title="And that’s it! Let’s start writing!"></a>And that’s it! Let’s start writing!</h1><ul>
<li><p>In your hexo root directory, start a new post:</p>
<pre><code>hexo new post
</code></pre></li>
<li><p>Preview your post with</p>
<pre><code>hexo server
</code></pre></li>
<li><p>In preview mode, Hexo will watch your files and automatically update the html. However, it <strong>will not</strong> publish any static assets (those eventually shown in your site). So run this to let hexo do it:</p>
<pre><code>hexo generate
</code></pre></li>
<li><p>Then commit the changes to your repo (You can automate this with a shell script.)</p>
</li>
</ul>
]]></content:encoded>
      
      <comments>http://xcorpion.tech/2016/08/14/get-started-with-hexo-blogging-system/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
